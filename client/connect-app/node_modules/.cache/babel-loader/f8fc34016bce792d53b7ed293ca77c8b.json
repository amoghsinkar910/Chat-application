{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _simpleUpdateIn = _interopRequireDefault(require(\"simple-update-in\"));\n\nvar _EventSpy = _interopRequireDefault(require(\"../EventSpy\"));\n\nvar _FunctionContext = _interopRequireDefault(require(\"./FunctionContext\"));\n\nvar _InternalContext = _interopRequireDefault(require(\"./InternalContext\"));\n\nvar _SpineTo = _interopRequireDefault(require(\"../SpineTo\"));\n\nvar _StateContext = _interopRequireDefault(require(\"./StateContext\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar MIN_CHECK_INTERVAL = 17; // 1 frame\n\nvar NEAR_END_THRESHOLD = 1;\nvar SCROLL_DECISION_DURATION = 34; // 2 frames\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState(_ref) {\n  var mode = _ref.stateContext.mode,\n      _ref$target = _ref.target,\n      offsetHeight = _ref$target.offsetHeight,\n      scrollHeight = _ref$target.scrollHeight,\n      scrollTop = _ref$target.scrollTop;\n  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  var atTop = scrollTop < NEAR_END_THRESHOLD;\n  var atEnd = mode === 'top' ? atTop : atBottom;\n  return {\n    atBottom: atBottom,\n    atEnd: atEnd,\n    atStart: !atEnd,\n    atTop: atTop\n  };\n}\n\nvar Composer = /*#__PURE__*/function (_React$Component) {\n  _inherits(Composer, _React$Component);\n\n  function Composer(props) {\n    var _this;\n\n    _classCallCheck(this, Composer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Composer).call(this, props));\n    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleScrollEnd = _this.handleScrollEnd.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._ignoreScrollEventBefore = 0;\n    _this.state = {\n      functionContext: {\n        scrollTo: function scrollTo(scrollTop) {\n          return _this.setState(function (_ref2) {\n            var stateContext = _ref2.stateContext;\n            return {\n              scrollTop: scrollTop,\n              stateContext: (0, _simpleUpdateIn.default)(stateContext, ['animating'], function () {\n                return true;\n              })\n            };\n          });\n        },\n        scrollToBottom: function scrollToBottom() {\n          return _this.state.functionContext.scrollTo('100%');\n        },\n        scrollToEnd: function scrollToEnd() {\n          var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),\n              _assertThisInitialize2 = _assertThisInitialize.state,\n              functionContext = _assertThisInitialize2.functionContext,\n              stateContext = _assertThisInitialize2.stateContext;\n\n          stateContext.mode === 'top' ? functionContext.scrollToTop() : functionContext.scrollToBottom();\n        },\n        scrollToStart: function scrollToStart() {\n          var _assertThisInitialize3 = _assertThisInitialized(_assertThisInitialized(_this)),\n              _assertThisInitialize4 = _assertThisInitialize3.state,\n              functionContext = _assertThisInitialize4.functionContext,\n              stateContext = _assertThisInitialize4.stateContext;\n\n          stateContext.mode === 'top' ? functionContext.scrollToBottom() : functionContext.scrollToTop();\n        },\n        scrollToTop: function scrollToTop() {\n          return _this.state.functionContext.scrollTo(0);\n        }\n      },\n      internalContext: {\n        offsetHeight: 0,\n        scrollHeight: 0,\n        setTarget: function setTarget(target) {\n          return _this.setState(function () {\n            return {\n              target: target\n            };\n          });\n        }\n      },\n      scrollTop: props.mode === 'top' ? 0 : '100%',\n      stateContext: {\n        animating: false,\n        atBottom: true,\n        atEnd: true,\n        atTop: true,\n        mode: props.mode,\n        sticky: true\n      },\n      target: null\n    };\n    return _this;\n  }\n\n  _createClass(Composer, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.enableWorker();\n    }\n  }, {\n    key: \"disableWorker\",\n    value: function disableWorker() {\n      clearInterval(this._stickyCheckTimeout);\n    }\n  }, {\n    key: \"enableWorker\",\n    value: function enableWorker() {\n      var _this2 = this;\n\n      clearInterval(this._stickyCheckTimeout);\n      var stickyButNotAtEndSince = false;\n      this._stickyCheckTimeout = setImmediateInterval(function () {\n        var state = _this2.state;\n        var sticky = state.stateContext.sticky,\n            target = state.target;\n\n        if (sticky && target && !computeViewState(state).atEnd) {\n          if (!stickyButNotAtEndSince) {\n            stickyButNotAtEndSince = Date.now();\n          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n            // Quirks: In Firefox, after user scroll down, Firefox do two things:\n            //         1. Set to a new \"scrollTop\"\n            //         2. Fire \"scroll\" event\n            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n            state.functionContext.scrollToEnd();\n            stickyButNotAtEndSince = false;\n          }\n        } else {\n          stickyButNotAtEndSince = false;\n        }\n      }, Math.max(MIN_CHECK_INTERVAL, this.props.checkInterval) || MIN_CHECK_INTERVAL);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.disableWorker();\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.setState(function (_ref3) {\n        var stateContext = _ref3.stateContext;\n        return {\n          stateContext: _objectSpread({}, stateContext, {\n            mode: nextProps.mode === 'top' ? 'top' : 'bottom'\n          })\n        };\n      });\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll(_ref4) {\n      var _this3 = this;\n\n      var timeStampLow = _ref4.timeStampLow; // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n      // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n      // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n      if (timeStampLow <= this._ignoreScrollEventBefore) {\n        // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n        // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n        // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n        return;\n      }\n\n      this.disableWorker();\n      this.setState(function (state) {\n        var target = state.target;\n\n        if (target) {\n          var internalContext = state.internalContext,\n              scrollTop = state.scrollTop,\n              stateContext = state.stateContext;\n\n          var _computeViewState = computeViewState(state),\n              atBottom = _computeViewState.atBottom,\n              atEnd = _computeViewState.atEnd,\n              atStart = _computeViewState.atStart,\n              atTop = _computeViewState.atTop;\n\n          var nextInternalContext = internalContext;\n          var nextStateContext = stateContext;\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atBottom'], function () {\n            return atBottom;\n          });\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atEnd'], function () {\n            return atEnd;\n          });\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atStart'], function () {\n            return atStart;\n          });\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atTop'], function () {\n            return atTop;\n          }); // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n          // We need to ignore these \"synthetic\" events\n          // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n          //        Nomatter how fast or slow the sequence is being presssed, it should still stick to the bottom\n\n          var offsetHeight = target.offsetHeight,\n              scrollHeight = target.scrollHeight;\n          var resized = offsetHeight !== internalContext.offsetHeight;\n          var elementChanged = scrollHeight !== internalContext.scrollHeight;\n\n          if (resized) {\n            nextInternalContext = (0, _simpleUpdateIn.default)(nextInternalContext, ['offsetHeight'], function () {\n              return offsetHeight;\n            });\n          }\n\n          if (elementChanged) {\n            nextInternalContext = (0, _simpleUpdateIn.default)(nextInternalContext, ['scrollHeight'], function () {\n              return scrollHeight;\n            });\n          } // Sticky means:\n          // - If it is scrolled programatically, we are still in sticky mode\n          // - If it is scrolled by the user, then sticky means if we are at the end\n          // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n\n\n          if (!resized && !elementChanged) {\n            nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['sticky'], function () {\n              return stateContext.animating ? true : atEnd;\n            });\n          } // If no scrollTop is set (not in programmatic scrolling mode), we should set \"animating\" to false\n          // \"animating\" is used to calculate the \"sticky\" property\n\n\n          if (scrollTop === null) {\n            nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['animating'], function () {\n              return false;\n            });\n          }\n\n          return _objectSpread({}, internalContext === nextInternalContext ? {} : {\n            internalContext: nextInternalContext\n          }, stateContext === nextStateContext ? {} : {\n            stateContext: nextStateContext\n          });\n        }\n      }, function () {\n        _this3.state.stateContext.sticky && _this3.enableWorker();\n      });\n    }\n  }, {\n    key: \"handleScrollEnd\",\n    value: function handleScrollEnd() {\n      // We should ignore debouncing handleScroll that emit before this time\n      this._ignoreScrollEventBefore = Date.now();\n      this.setState(function () {\n        return {\n          scrollTop: null\n        };\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var handleScroll = this.handleScroll,\n          handleScrollEnd = this.handleScrollEnd,\n          _this$props = this.props,\n          children = _this$props.children,\n          debounce = _this$props.debounce,\n          _this$state = this.state,\n          functionContext = _this$state.functionContext,\n          internalContext = _this$state.internalContext,\n          scrollTop = _this$state.scrollTop,\n          stateContext = _this$state.stateContext,\n          target = _this$state.target;\n      return _react.default.createElement(_InternalContext.default.Provider, {\n        value: internalContext\n      }, _react.default.createElement(_FunctionContext.default.Provider, {\n        value: functionContext\n      }, _react.default.createElement(_StateContext.default.Provider, {\n        value: stateContext\n      }, children, target && _react.default.createElement(_EventSpy.default, {\n        debounce: debounce,\n        name: \"scroll\",\n        onEvent: handleScroll,\n        target: target\n      }), target && scrollTop !== null && _react.default.createElement(_SpineTo.default, {\n        name: \"scrollTop\",\n        onEnd: handleScrollEnd,\n        target: target,\n        value: scrollTop\n      }))));\n    }\n  }]);\n\n  return Composer;\n}(_react.default.Component);\n\nexports.default = Composer;\nComposer.defaultProps = {\n  checkInterval: 100,\n  debounce: 17\n};\nComposer.propTypes = {\n  checkInterval: _propTypes.default.number,\n  debounce: _propTypes.default.number\n};","map":{"version":3,"sources":["../../src/ScrollToBottom/Composer.js"],"names":["MIN_CHECK_INTERVAL","NEAR_END_THRESHOLD","SCROLL_DECISION_DURATION","fn","setInterval","stateContext","mode","target","offsetHeight","scrollHeight","scrollTop","atBottom","atTop","atEnd","atStart","Composer","React","Component","functionContext","scrollTo","scrollToBottom","scrollToEnd","scrollToStart","scrollToTop","internalContext","setTarget","props","animating","sticky","clearInterval","stickyButNotAtEndSince","setImmediateInterval","state","computeViewState","Date","Math","nextProps","timeStampLow","nextInternalContext","nextStateContext","resized","elementChanged","handleScroll","handleScrollEnd","children","debounce","checkInterval","PropTypes","number"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport updateIn from 'simple-update-in';\n\nimport EventSpy from '../EventSpy';\nimport FunctionContext from './FunctionContext';\nimport InternalContext from './InternalContext';\nimport SpineTo from '../SpineTo';\nimport StateContext from './StateContext';\n\nconst MIN_CHECK_INTERVAL = 17;       // 1 frame\nconst NEAR_END_THRESHOLD = 1;\nconst SCROLL_DECISION_DURATION = 34; // 2 frames\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState({ stateContext: { mode }, target: { offsetHeight, scrollHeight, scrollTop } }) {\n  const atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  const atTop = scrollTop < NEAR_END_THRESHOLD;\n  const atEnd = mode === 'top' ? atTop : atBottom;\n\n  return {\n    atBottom,\n    atEnd,\n    atStart: !atEnd,\n    atTop\n  };\n}\n\nexport default class Composer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.handleScroll = this.handleScroll.bind(this);\n    this.handleScrollEnd = this.handleScrollEnd.bind(this);\n\n    this._ignoreScrollEventBefore = 0;\n\n    this.state = {\n      functionContext: {\n        scrollTo: scrollTop => this.setState(({ stateContext }) => ({\n          scrollTop,\n          stateContext: updateIn(stateContext, ['animating'], () => true)\n        })),\n        scrollToBottom: () => this.state.functionContext.scrollTo('100%'),\n        scrollToEnd: () => {\n          const { state: { functionContext, stateContext } } = this;\n\n          stateContext.mode === 'top' ? functionContext.scrollToTop() : functionContext.scrollToBottom();\n        },\n        scrollToStart: () => {\n          const { state: { functionContext, stateContext } } = this;\n\n          stateContext.mode === 'top' ? functionContext.scrollToBottom() : functionContext.scrollToTop();\n        },\n        scrollToTop: () => this.state.functionContext.scrollTo(0)\n      },\n      internalContext: {\n        offsetHeight: 0,\n        scrollHeight: 0,\n        setTarget: target => this.setState(() => ({ target }))\n      },\n      scrollTop: props.mode === 'top' ? 0 : '100%',\n      stateContext: {\n        animating: false,\n        atBottom: true,\n        atEnd: true,\n        atTop: true,\n        mode: props.mode,\n        sticky: true\n      },\n      target: null\n    };\n  }\n\n  componentDidMount() {\n    this.enableWorker();\n  }\n\n  disableWorker() {\n    clearInterval(this._stickyCheckTimeout);\n  }\n\n  enableWorker() {\n    clearInterval(this._stickyCheckTimeout);\n\n    let stickyButNotAtEndSince = false;\n\n    this._stickyCheckTimeout = setImmediateInterval(\n      () => {\n        const { state } = this;\n        const { stateContext: { sticky }, target } = state;\n\n        if (\n          sticky\n          && target\n          && !computeViewState(state).atEnd\n        ) {\n          if (!stickyButNotAtEndSince) {\n            stickyButNotAtEndSince = Date.now();\n          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n            // Quirks: In Firefox, after user scroll down, Firefox do two things:\n            //         1. Set to a new \"scrollTop\"\n            //         2. Fire \"scroll\" event\n            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n\n            state.functionContext.scrollToEnd();\n            stickyButNotAtEndSince = false;\n          }\n        } else {\n          stickyButNotAtEndSince = false;\n        }\n      },\n      Math.max(MIN_CHECK_INTERVAL, this.props.checkInterval) || MIN_CHECK_INTERVAL\n    );\n  }\n\n  componentWillUnmount() {\n    this.disableWorker();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setState(({ stateContext }) => ({\n      stateContext: {\n        ...stateContext,\n        mode: nextProps.mode === 'top' ? 'top' : 'bottom'\n      }\n    }));\n  }\n\n  handleScroll({ timeStampLow }) {\n    // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n    // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n    if (timeStampLow <= this._ignoreScrollEventBefore) {\n      // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n      // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n\n      return;\n    }\n\n    this.disableWorker();\n\n    this.setState(state => {\n      const { target } = state;\n\n      if (target) {\n        const { internalContext, scrollTop, stateContext } = state;\n        const { atBottom, atEnd, atStart, atTop } = computeViewState(state);\n        let nextInternalContext = internalContext;\n        let nextStateContext = stateContext;\n\n        nextStateContext = updateIn(nextStateContext, ['atBottom'], () => atBottom);\n        nextStateContext = updateIn(nextStateContext, ['atEnd'], () => atEnd);\n        nextStateContext = updateIn(nextStateContext, ['atStart'], () => atStart);\n        nextStateContext = updateIn(nextStateContext, ['atTop'], () => atTop);\n\n        // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n        // We need to ignore these \"synthetic\" events\n        // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n        //        Nomatter how fast or slow the sequence is being presssed, it should still stick to the bottom\n        const { offsetHeight, scrollHeight } = target;\n        const resized = offsetHeight !== internalContext.offsetHeight;\n        const elementChanged = scrollHeight !== internalContext.scrollHeight;\n\n        if (resized) {\n          nextInternalContext = updateIn(nextInternalContext, ['offsetHeight'], () => offsetHeight);\n        }\n\n        if (elementChanged) {\n          nextInternalContext = updateIn(nextInternalContext, ['scrollHeight'], () => scrollHeight);\n        }\n\n        // Sticky means:\n        // - If it is scrolled programatically, we are still in sticky mode\n        // - If it is scrolled by the user, then sticky means if we are at the end\n\n        // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n        if (!resized && !elementChanged) {\n          nextStateContext = updateIn(nextStateContext, ['sticky'], () => stateContext.animating ? true : atEnd);\n        }\n\n        // If no scrollTop is set (not in programmatic scrolling mode), we should set \"animating\" to false\n        // \"animating\" is used to calculate the \"sticky\" property\n        if (scrollTop === null) {\n          nextStateContext = updateIn(nextStateContext, ['animating'], () => false);\n        }\n\n        return {\n          ...internalContext === nextInternalContext ? {} : { internalContext: nextInternalContext },\n          ...stateContext === nextStateContext ? {} : { stateContext: nextStateContext }\n        };\n      }\n    }, () => {\n      this.state.stateContext.sticky && this.enableWorker();\n    });\n  }\n\n  handleScrollEnd() {\n    // We should ignore debouncing handleScroll that emit before this time\n    this._ignoreScrollEventBefore = Date.now();\n\n    this.setState(() => ({ scrollTop: null }));\n  }\n\n  render() {\n    const {\n      handleScroll,\n      handleScrollEnd,\n      props: { children, debounce },\n      state: { functionContext, internalContext, scrollTop, stateContext, target }\n    } = this;\n\n    return (\n      <InternalContext.Provider value={ internalContext }>\n        <FunctionContext.Provider value={ functionContext }>\n          <StateContext.Provider value={ stateContext }>\n            { children }\n            {\n              target &&\n                <EventSpy\n                  debounce={ debounce }\n                  name=\"scroll\"\n                  onEvent={ handleScroll }\n                  target={ target }\n                />\n            }\n            {\n              target && scrollTop !== null &&\n                <SpineTo\n                  name=\"scrollTop\"\n                  onEnd={ handleScrollEnd }\n                  target={ target }\n                  value={ scrollTop }\n                />\n            }\n          </StateContext.Provider>\n        </FunctionContext.Provider>\n      </InternalContext.Provider>\n    );\n  }\n}\n\nComposer.defaultProps = {\n  checkInterval: 100,\n  debounce: 17\n};\n\nComposer.propTypes = {\n  checkInterval: PropTypes.number,\n  debounce: PropTypes.number\n};\n"]},"metadata":{},"sourceType":"script"}